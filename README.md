## Тестовое задание: сервис для рассылки уведомлений об истекающих подписках

Code style: давно не писал, не объектный код без фреймворка.
Cтарался писать в одном стиле который близок к Symfony. Кроме 2х функций, явно указанных в ТЗ

Проверял на PHP 8.1

Все запускал из консоли, но можно и через веб запускать, но там тогда надо с таймаутами проверить, 
чтоб время выполнения скрипта за настройки вебсервера не выходило.

Старался учесть максимум разных вариантов и сделать оптимизации, но недостатки найти можно ))) 


### Общий принцип:

```config.php``` коннект к базе и оптимизации по количеству потоков и количество строк для обработки в потоке

```init_dataset.php``` создаются таблицы и 1.000.000 пользователей.
80% пользователей email подтвержден, 20% не подвержден (мне кажется это близка к правде, на части проектов)

```drop_project_tables.php``` удалить все. больше тестовый скрипт для удобства разработки

Скрипты отправки можно (нужно) поставить в крон и запускать раз в минуту. Они проверяют сколько копий запущено, 
количество копий скрипта задается в конфиге. Таким образом крон запустит много процессов в бэкграунде.
Но чтоб бы они все работали, надо тогда им большие количества строк задавать, а то по 100 процессов не запустится.
В идеале бы supervisord использовать, но пускай будет cron для простоты. 
Архитектурно должно и на нескольких серверах с общей базой данных работать, но не проверял.

```start_checker.php``` проверяет валидность подтвержденных email из users и пишет их в emails. 
При запуске помечает записи, каким процессом будет выполнять. По умолчанию проверяет 15 email и выходит (~450 секунд)

```start_sender.php``` отправляет письма из "проверенных" из таблицы emails. При запуске копирует
часть из emails и помечает каким процессом будет выполнять. По умолчанию отправляет 100 писем и выходит (~500 секунд)

Выбрал такие цифры, просто потому что мне так тестировать было удобно. 
Можно больше за запуск проверять, так меньше простой у скриптов будет.

В моем примере можно посчитать время отправки всех писем. Берем среднее время выполнения. Конечно, медианное время может не совпадать со средним.
1. Письма на подтвержденные адреса начинают уходить сразу после запуска, не ожидая проверки не подтвержденных
2. Параллельно идет проверка валидности и тем которые проверены - тоже отправляются письма, с учетом наступления даты платежа.
3. В моих данных примерно 800.000 адресов валидных и 100.000 будет валидными после проверки (50% вероятность после проверки)
4. 200.000 не валидных будет проверяться со скоростью 120 адресов в час на процесс. Надо где-то 160 процессов проверки, что бы за 10-11 часов примерно все проверить.
5. 900.000 писем будет рассылаться примерно 720 писем в час на процесс. Надо где-то 120 процессов, что бы за 10-11 часов все отправить.


### Одновременный запуск
Т.к. для достижения нужного числа потоков надо запускать одновременно много раз скрипт, а разбираться с supervisord не хотелось,
то для тестов использовал команду типа
```
php start_checker.php&  php start_checker.php&  php start_checker.php&  php start_checker.php
php start_sender.php&  php start_sender.php&  php start_sender.php&  php start_sender.php
```
При таком запуске происходит одновременная попытка записать много строк в таблицы и deadlock.
По этому для больших insert строк из других таблиц используем randomSleep() что бы в разное время вставка была.
На последующие проверки и отправки это не влияет, там идет обновление одной строки за раз по ```id``` и нет deadlock.

Вроде можно настроить ```innodb_lock_wait_timeout``` но я не могу это проверить на вашем сервере, по этому, исходим из того что есть.

Можно еще на ```bash``` скрипт написать для параллельного запуска и т.д. 


### Логика работы таблиц
Таблица users:
* Индекс по полю username не делаем, т.к. в запросах не участвует. Но в нормальном проекте конечно должен быть уникальный индекс
* Не указано, что почта или username в таблице пользователей уникальны. В норме это всегда так. Делаем уникальный индекс по полю email, а по username не делаем, т.к. не используем в проекте
* Делаем индекс по полю validts для быстрой сортировки по дате.
* confirmed - считаем что если поле = 1, то email валидный, иначе как бы пользователь его подтвердил

Таблица emails (проверенные адреса):
* Уникальный индекс по email, там точно не может быть повторений. Так же нужно для join таблиц.
* Сhecked - это заполняется только для email, где нужна проверка. Если email уже был confirmed, то не проверяем.
* Индекс по valid, нужно для быстрого select. Если email уже был confirmed, то сразу ставим = 1

Таблица emails_sent (отправленные письма):
* Уникальный индекс по email, там точно не может быть повторений. Так же нужно для join таблиц.
* sent_time - обновляется при отправке. что бы поле было не null, так быстрее
* sent - обновляется при отправке. реальное значение, было ли отправлено.

Таблица runners:
* список запущенных процессов и их статус
* раздельно идут процессы на проверку и на отправку
* last_time - это такой watchdog. Показывает, как давно скрипт был активен.
* если скрипт помер от ошибки или процесс убили, то при запуске соответствующего скрипта проверяется такая ситуация. Записи которые не были обработаны - удаляются из конечных таблиц и не обработанные email будут повторно взяты новым процессом. 
